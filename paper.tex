% This template has been tested with LLNCS DOCUMENT CLASS -- version 2.20 (10-Mar-2018)

% !TeX spellcheck = en-US
% !TeX encoding = utf8
% !TeX program = pdflatex
% !BIB program = bibtex
% -*- coding:utf-8 mod:LaTeX -*-

% "a4paper" enables:
%  - easy print out on DIN A4 paper size
%
% One can configure a4 vs. letter in the LaTeX installation. So it is configuration dependend, what the paper size will be.
% This option  present, because the current word template offered by Springer is DIN A4.
% We accept that DIN A4 cause WTFs at persons not used to A4 in USA.

% "runningheads" enables:
%  - page number on page 2 onwards
%  - title/authors on even/odd pages
% This is good for other readers to enable proper archiving among other papers and pointing to
% content. Even if the title page states the title, when printed and stored in a folder, when
% blindly opening the folder, one could hit not the title page, but an arbitrary page. Therefore,
% it is good to have title printed on the pages, too.
%
% It is enabled by default as the springer template as of 2018/03/10 uses this as default

% German documents: pass ngerman as class option
% \documentclass[ngerman,runningheads,a4paper]{llncs}[2018/03/10]
% English documents: pass english as class option
\documentclass[english,runningheads,a4paper]{llncs}[2018/03/10]

%% If you need packages for other papers,
%% START COPYING HERE

% Set English as language and allow to write hyphenated"=words
%
% In case you write German, switch the parameters, so that the command becomes
%\usepackage[english,main=ngerman]{babel}
%
% Even though `american`, `english` and `USenglish` are synonyms for babel package (according to https://tex.stackexchange.com/questions/12775/babel-english-american-usenglish), the llncs document class is prepared to avoid the overriding of certain names (such as "Abstract." -> "Abstract" or "Fig." -> "Figure") when using `english`, but not when using the other 2.
% english has to go last to set it as default language
\usepackage[ngerman,main=english]{babel}
%
% Hint by http://tex.stackexchange.com/a/321066/9075 -> enable "= as dashes
\addto\extrasenglish{\languageshorthands{ngerman}\useshorthands{"}}
%
% Fix by https://tex.stackexchange.com/a/441701/9075
\usepackage{regexpatch}
\makeatletter
\edef\switcht@albion{%
  \relax\unexpanded\expandafter{\switcht@albion}%
}
\xpatchcmd*{\switcht@albion}{ \def}{\def}{}{}
\xpatchcmd{\switcht@albion}{\relax}{}{}{}
\edef\switcht@deutsch{%
  \relax\unexpanded\expandafter{\switcht@deutsch}%
}
\xpatchcmd*{\switcht@deutsch}{ \def}{\def}{}{}
\xpatchcmd{\switcht@deutsch}{\relax}{}{}{}
\edef\switcht@francais{%
  \relax\unexpanded\expandafter{\switcht@francais}%
}
\xpatchcmd*{\switcht@francais}{ \def}{\def}{}{}
\xpatchcmd{\switcht@francais}{\relax}{}{}{}
\makeatother

\usepackage{ifluatex}
\ifluatex
  \usepackage{fontspec}
  \usepackage[english]{selnolig}
\fi

\iftrue % use default-font
  \ifluatex
    % use the better (sharper, ...) Latin Modern variant of Computer Modern
    \setmainfont{Latin Modern Roman}
    \setsansfont{Latin Modern Sans}
    \setmonofont{Latin Modern Mono} % "variable=false"
    %\setmonofont{Latin Modern Mono Prop} % "variable=true"
  \else
    % better font, similar to the default springer font
    % cfr-lm is preferred over lmodern. Reasoning at http://tex.stackexchange.com/a/247543/9075
    \usepackage[%
      rm={oldstyle=false,proportional=true},%
      sf={oldstyle=false,proportional=true},%
      tt={oldstyle=false,proportional=true,variable=false},%
      qt=false%
    ]{cfr-lm}
  \fi
\else
  % In case more space is needed, it is accepted to use Times New Roman
  \ifluatex
    \setmainfont{TeX Gyre Termes}
    \setsansfont[Scale=.9]{TeX Gyre Heros}
    % newtxtt looks good with times, but no equivalent for lualatex found,
    % therefore tried to replace with inconsolata.
    % However, inconsolata does not look good in the context of LNCS ...
    %\setmonofont[StylisticSet={1,3},Scale=.9]{inconsolata}
    % ... thus, we use the good old Latin Modern Mono font for source code.
    \setmonofont{Latin Modern Mono} % "variable=false"
    %\setmonofont{Latin Modern Mono Prop} % "variable=true"
  \else
    % overwrite cmodern with the Times variant
    \usepackage{newtxtext}
    \usepackage{newtxmath}
    \usepackage[zerostyle=b,scaled=.9]{newtxtt}
  \fi
\fi

\ifluatex
\else
  % fontenc and inputenc are not required when using lualatex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc} %support umlauts in the input
\fi

\usepackage{graphicx}

% backticks (`) are rendered as such in verbatim environment. See https://tex.stackexchange.com/a/341057/9075 for details.
\usepackage{upquote}

% Nicer tables (\toprule, \midrule, \bottomrule - see example)
\usepackage{booktabs}

%extended enumerate, such as \begin{compactenum}
\usepackage{paralist}

%put figures inside a text
%\usepackage{picins}
%use
%\piccaptioninside
%\piccaption{...}
%\parpic[r]{\includegraphics ...}
%Text...

% For easy quotations: \enquote{text}
% This package is very smart when nesting is applied, otherwise textcmds (see below) provides a shorter command
\usepackage{csquotes}

% For even easier quotations: \qq{text}
\usepackage{textcmds}

%enable margin kerning
\RequirePackage[%
  babel,%
  final,%
  expansion=alltext,%
  protrusion=alltext-nott]{microtype}%
% \texttt{test -- test} keeps the "--" as "--" (and does not convert it to an en dash)
\DisableLigatures{encoding = T1, family = tt* }

%tweak \url{...}
\usepackage{url}
%\urlstyle{same}
%improve wrapping of URLs - hint by http://tex.stackexchange.com/a/10419/9075
\makeatletter
\g@addto@macro{\UrlBreaks}{\UrlOrds}
\makeatother
%nicer // - solution by http://tex.stackexchange.com/a/98470/9075
%DO NOT ACTIVATE -> prevents line breaks
%\makeatletter
%\def\Url@twoslashes{\mathchar`\/\@ifnextchar/{\kern-.2em}{}}
%\g@addto@macro\UrlSpecials{\do\/{\Url@twoslashes}}
%\makeatother

% Diagonal lines in a table - http://tex.stackexchange.com/questions/17745/diagonal-lines-in-table-cell
% Slashbox is not available in texlive (due to licensing) and also gives bad results. This, we use diagbox
%\usepackage{diagbox}

% Required for package pdfcomment later
\usepackage{xcolor}

% For listings
\usepackage{listings}
\lstset{%
  basicstyle=\ttfamily,%
  columns=fixed,%
  basewidth=.5em,%
  xleftmargin=0.5cm,%
  captionpos=b}%
\renewcommand{\lstlistingname}{List.}
% Fix counter as described at https://tex.stackexchange.com/a/28334/9075
\usepackage{chngcntr}
\AtBeginDocument{\counterwithout{lstlisting}{section}}

% Enable nice comments
\usepackage{pdfcomment}
%
\newcommand{\commentontext}[2]{\colorbox{yellow!60}{#1}\pdfcomment[color={0.234 0.867 0.211},hoffset=-6pt,voffset=10pt,opacity=0.5]{#2}}
\newcommand{\commentatside}[1]{\pdfcomment[color={0.045 0.278 0.643},icon=Note]{#1}}
%
% Compatibality with packages todo, easy-todo, todonotes
\newcommand{\todo}[1]{\commentatside{#1}}
% Compatiblity with package fixmetodonotes
\newcommand{\TODO}[1]{\commentatside{#1}}

% Bibliopgraphy enhancements
%  - enable \cite[prenote][]{ref}
%  - enable \cite{ref1,ref2}
% Alternative: \usepackage{cite}, which enables \cite{ref1, ref2} only (otherwise: Error message: "White space in argument")

% Doc: http://texdoc.net/natbib
\usepackage[%
  square,        % for square brackets
  comma,         % use commas as separators
  numbers,       % for numerical citations;
%  sort,          % orders multiple citations into the sequence in which they appear in the list of references;
  sort&compress, % as sort but in addition multiple numerical citations
                 % are compressed if possible (as 3-6, 15);
]{natbib}
% In the bibliography, references have to be formatted as 1., 2., ... not [1], [2], ...
\renewcommand{\bibnumfmt}[1]{#1.}

\ifluatex
  % does not work when using luatex
  % see: https://tex.stackexchange.com/q/419288/9075
\else
  % Prepare more space-saving rendering of the bibliography
  % Source: https://tex.stackexchange.com/a/280936/9075
  \SetExpansion
  [ context = sloppy,
    stretch = 30,
    shrink = 60,
    step = 5 ]
  { encoding = {OT1,T1,TS1} }
  { }
\fi

% Put footnotes below floats
% Source: https://tex.stackexchange.com/a/32993/9075
\usepackage{stfloats}
\fnbelowfloat

% Enable that parameters of \cref{}, \ref{}, \cite{}, ... are linked so that a reader can click on the number an jump to the target in the document
\usepackage{hyperref}
% Enable hyperref without colors and without bookmarks
\hypersetup{hidelinks,
  colorlinks=true,
  allcolors=black,
  pdfstartview=Fit,
  breaklinks=true}
%
% Enable correct jumping to figures when referencing
\usepackage[all]{hypcap}

\usepackage[group-four-digits,per-mode=fraction]{siunitx}

%enable \cref{...} and \Cref{...} instead of \ref: Type of reference included in the link
\usepackage[capitalise,nameinlink]{cleveref}
%Nice formats for \cref
\usepackage{iflang}
\IfLanguageName{ngerman}{
  \crefname{table}{Tab.}{Tab.}
  \Crefname{table}{Tabelle}{Tabellen}
  \crefname{figure}{\figurename}{\figurename}
  \Crefname{figure}{Abbildungen}{Abbildungen}
  \crefname{equation}{Gleichung}{Gleichungen}
  \Crefname{equation}{Gleichung}{Gleichungen}
  \crefname{listing}{\lstlistingname}{\lstlistingname}
  \Crefname{listing}{Listing}{Listings}
  \crefname{section}{Abschnitt}{Abschnitte}
  \Crefname{section}{Abschnitt}{Abschnitte}
  \crefname{paragraph}{Abschnitt}{Abschnitte}
  \Crefname{paragraph}{Abschnitt}{Abschnitte}
  \crefname{subparagraph}{Abschnitt}{Abschnitte}
  \Crefname{subparagraph}{Abschnitt}{Abschnitte}
}{
  \crefname{section}{Sect.}{Sect.}
  \Crefname{section}{Section}{Sections}
  \crefname{listing}{\lstlistingname}{\lstlistingname}
  \Crefname{listing}{Listing}{Listings}
}


%Intermediate solution for hyperlinked refs. See https://tex.stackexchange.com/q/132420/9075 for more information.
\newcommand{\Vlabel}[1]{\label[line]{#1}\hypertarget{#1}{}}
\newcommand{\lref}[1]{\hyperlink{#1}{\FancyVerbLineautorefname~\ref*{#1}}}

\usepackage{xspace}
%\newcommand{\eg}{e.\,g.\xspace}
%\newcommand{\ie}{i.\,e.\xspace}
\newcommand{\eg}{e.\,g.,\ }
\newcommand{\ie}{i.\,e.,\ }

%introduce \powerset - hint by http://matheplanet.com/matheplanet/nuke/html/viewtopic.php?topic=136492&post_id=997377
\DeclareFontFamily{U}{MnSymbolC}{}
\DeclareSymbolFont{MnSyC}{U}{MnSymbolC}{m}{n}
\DeclareFontShape{U}{MnSymbolC}{m}{n}{
  <-6>    MnSymbolC5
  <6-7>   MnSymbolC6
  <7-8>   MnSymbolC7
  <8-9>   MnSymbolC8
  <9-10>  MnSymbolC9
  <10-12> MnSymbolC10
  <12->   MnSymbolC12%
}{}
\DeclareMathSymbol{\powerset}{\mathord}{MnSyC}{180}

\ifluatex
\else
  % Enable copy and paste - also of numbers
  % This has to be done instead of \usepackage{cmap}, because it does not work together with cfr-lm.
  % See: https://tex.stackexchange.com/a/430599/9075
  \input glyphtounicode
  \pdfgentounicode=1
\fi

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

%% END COPYING HERE


% Add copyright
% Do that for the final version or if you send it to colleagues
\iffalse
  %state: intended|submitted|llncs
  %you can add "crop" if the paper should be cropped to the format Springer is publishing
  \usepackage[intended]{llncsconf}

  \conference{name of the conference}

  %in case of "llncs" (final version!)
  %example: llncs{Anonymous et al. (eds). \emph{Proceedings of the International Conference on \LaTeX-Hacks}, LNCS~42. Some Publisher, 2016.}{0042}
  \llncs{book editors and title}{0042} %% 0042 is the start page
\fi

% For demonstration purposes only
\usepackage[math]{blindtext}
\usepackage{mwe}


\begin{document}

\title{Secure Multi-Party Computation with SCALE-MAMBA}
%If Title is too long, use \titlerunning
%\titlerunning{Short Title}

%Single insitute
\author{Jonas Rülfing}
%If there are too many authors, use \authorrunning
%\authorrunning{First Author et al.}
\institute{Seminar: Privacy and Big Data - RWTH Aachen}

%% Multiple insitutes - ALTERNATIVE to the above
% \author{%
%     Firstname Lastname\inst{1} \and
%     Firstname Lastname\inst{2}
% }
%
%If there are too many authors, use \authorrunning
%  \authorrunning{First Author et al.}
%
%  \institute{
%      Insitute 1\\
%      \email{...}\and
%      Insitute 2\\
%      \email{...}
%}

\maketitle

\begin{abstract}
  This thesis takes a look at SMPC especally using SCALE-MAMBA. For that it introduces first what SMPC is,  how SPDZ the precessor of SCALE-MAMBA works and what are the differences. It discusses the functionalities of SCALE-MAMBA, especially the split into online and offline phase, how the beaver tripels are used for sacrificing and in which complexity classes the calculations are done. Finally it compares scale mamba shortly to other competitors in the market and gives an outlook what next technologies are coming right now and are coming in the near future in SMPC.
\end{abstract}

\section{Motivation and Introduction}\label{sec:intromoti}

In todays world, and even more in the future, there are a lot of computations that have to be done in a distributed environment, this might be because there are different parties involved, but also because the amount of data is getting so big that it becomes impossible to have a single entity that processes all the data at once. Furthermore, in a lot of these cases the parties participating in these computations don't want to reveal their own information, because its sensitive or because they don't want to share information with a lot of business value.\\
A basic example is an anonymized voting. In most elections there is a third party that has to aggregate and count the votings made by the votings. For instance in germanys elections this is done by specific people counting a small group of votes and then forwarding the information. The other problem is that it has to be guaranteed that a vote is valid, meaning that the voter has the right to vote and is only voting one time. So if there would be a malicious person in the system, it would be easy for that person to figure out what vote a specific person made.\\
Another use case is the exchange of medical data. Medical data of patients is highly confidential and shoudn't be publiced under n circumstances. But at the same time a lot of different hospitals or doctors have only the data from their small data set of local patients, and for making diagnosis for new patients it is helpful to compare the symptoms to the diagnosis of other doctors.\\
Secure Multi-Party Computation(SMPC) is one possible solution for these use cases. It is a field of research that emerged in the last 30 years, and is gathering a lot of speed in the last years. 
The basic problem is how to evaluate a common function in which multiple parties have different inputs to this function, without revealing the different inputs of the parties. Although there are a lot of theoretical solutions for this problem, real-world implementations are still not perfmorming on the desired level. So in the last years the research shifted more in the area on how to make the existant solutions performant enough while still guaranteeing a desired level of security.\\
This paper's main focus will lay on SCALE-MAMBA, a system developed mainly by the KU Leuven, which is one of the frontrunners in SMPC and a system that combines a lot of research by different teams with the newest ongoing research to provide a platform with highly performant SMPC. Nevertheless, this paper will at first give a short history of SMPC and will try to explain the basic technologies of SMPC to the reader. It will compare SCALE-MAMBA to its predecessors and will also try to give a short comparision to other SMPC systems which use different approaches, especially considering the usability in different use cases. Ultimately, it will try to give an outlook what might be coming in the next years.\\



a)	Motivation: 
-	Sometimes hard to know who to trust 
-	Problem: want to compute something together but we don’t want to share our information
-	A lot of use cases: number of distributed environments is climbing rapidly; for example see crypto currencies (distributed block chain; no one can do something alone, everyone relies on everyone else (or at least on a majority of the other participants)
o	Implements a lot of the theoretical foundations
o	Crypto suit, end to end
o	Possible to be safe against corruption with abort
o	Good (compared to others) execution times
o	Improvement of before existing technologies (SPDZ especially, and others)
o	This thesis will try to give an overview over Secure Multiparty Computation, especially focusing on Scale-Mamba and all the technologies it builds upon. Therefore, it will explain the basic technologies first in an abstracted manner and later go more into detail. 




\section{Cryptography Basics}\label{sec:basics}

Before diving deeper into SMPC, this section will shortly recap on cryptography basics that might be unknown to the reader. These basics are not solely used by SMPC, but nevertheless, play a huge role in a lot of protocols.

\subsection{Message Authentification Codes}
Message Authentification Codes (MACs) are used to guarantee the integrity and authenticity of a message. Basically, a MAC is a tag that is generated for a message and that, if it is correct, verifies the identity of the sender and that the content of the message was not changed.\\
For using MACs we need a tupel of two algorithms \((\text{MAC},\text{VER})\):\\
\begin{itemize}
\item The MAC algorithm \(\text{MAC}(K,m)\rightarrow t\) takes a key \(K\) and a message \(m\) and outputs a tag \(t\)\\
\item The verficiation algorithm \(\text{VER}(K,m,t)\rightarrow 0/1\) takes a key \(K\), a message \(m\) and a tag \(t\) and outputs accept(\(1\)) or reject(\(0\))\\
\end{itemize}
The correctness can be easily seen: \(\forall K: \text{VER}(K,m,\text{MAC}(K,m))=1\)\\

Continuing, we will not really care what exact underlying algorithms are used, we will just assume that the MACs used are indistingushiable against chosen-plaintext attack, i.e. an adversary which is bounded by polynomial time and which doesn't know the key, cannot get any information about the key even if he inputs as many different texts as he wants, chosen by himself,  into the MAC funtion. MAC functions which fulfill these critierias and are commonly used are for instance A, B and C.\\


In SCALE-MAMBA really simple MACs are used. We assume that a mac is 

Do we assume , that we use MAC code as multiplication, division? i.e. distributed MAC 

unconditionally  secure  MACs 


\subsection{Homomorphic Encryption}
Encryption as a basic concept is simple. Similiar to MACs, a tupel (E,D) of algorithms is needed.\\
\begin{itemize}
\item The enncryption algorithm \(\text{E}(K,m)\rightarrow c\) takes a key \(K\) and a message \(m\) and outputs a cyphertext \(t\) that is the encryption of the message \(m\)\\
\item The decryption algorithm \(\text{D}(K,c)\rightarrow m\) takes a key \(K\) and a cyphertext \(m\) and outputs the decrypted message \(m\), assuming c was not modified\\
\end{itemize}
Alternatively, in a public key setting, the key for encryption is public and there is a different key for decryption that is privat.\\
The problem is, that modifying the cypertext in any way makes the decryption useless. In some cases it is desirable do do computations on cypertexts, because then it is possible to make calculations without revealing the unencrypted data. That is why Homomorphic Encryption was developed. Let's assume that we have a ring \((R,+,*)\) as our message space. Fully Homomorphic Encryption (FHE) is preserving the ring structure. Therefore, it is possible to do additions and multiplications of cypertexts and when decrypting the result it is the same value as when doing the same additions and multiplications on the real values.\\
Althought FHE has amazing properties for a lot of usecases, in praxis it is way too slow. Because of all the overhead generated by the encryption scheme to guarantee the preservation of the ring structure, the current algorithms are not feasible for most applications.

\subsection{Somewhat Homomorphic Encryption}
That is where Somewhat Homomorphic Encryption (SHE) becomes relevant. SHE only supports one operation, and in most cases that is addition. This takes away a lot of possibilities but, therefore, the performance gain is immense. So immense, that SHE is used a lot in practice, for example in SCALE-MAMBA.\\
The SHE scheme used in SCALE-MAMBA, is based on the so called Brakerski-Gentry-Vaikuntanathan cryptosystem(BGV).\\



//e)	Access structures?
//f)	Monotone Span Programs (MSP) ?
h)	Different adversary types
a.	Malicious
b.	Honest but corious

\subsection{Adversary types}
Cryptography is the science of protecting information or communication from an adversary. This adversary is normally a third party that wants to get information for his own gain or want to sabotage something because of his own interest. In the are of SMPC we we normally divide between two types of adversaries. In SMPC we expect that everyone but ourselves can be controlled by an adversary.  That means the adversary can control between one and all of the other parties with which we are communicating. The difference to the normal cryptographic adversary model is, that the adversary is one of the parties we are communicating with but not a third party that tries to intercept communication.
\subsubsection{Honest but curious}
This type of adversary tries to gain as much information as possible. But this adversary is obeying to the rules of our protocol, that means it is impossible to know that this party is controlled by a third entity. This adversary tries to retrieve some of the secret information from the other parties, by using all the information he gets during the execution of the protocol.

\subsection{Malicious adversary}
While this adversary also wants to gain all the information, he is not obeying to the rules of the protocol. This type of adverary can send different inputs to manipulate the results he receives. Furthermore, he wants to interrupt the whole protocol. That could mean making the computation impossible, but as well modifying his own input or his own calculations, so the final result is changed and might lead to different implications

It is important to decide between these two types of adversary, because it shows the different securities SMPC has to guarantee. It has to guarantee that no information is unwillingly shared with an illegal party and at the same time verify that the final result has a correct value.


Maybe move this behind the basic introduction of SMPC? Some parts like access structures 



\section{SMPC Basics and History}\label{sec:smpc}
\subsection{Beginnings}
As we saw in the introduction, there are a lot current and much more upcoming usecases of calculating the output of a function in a distributed environment with multiple parties while at the same time keeping all the individual inputs secret. The first explorations in these fields started in the 1970s, with theoretical problems like the mental poker problem(how can two players play poker while not being in the same physical location and making sure noone is cheating) and Yaos millionaire problem(how can can two millionaires decide who is richer than the other while not revealing their wealth). \newline
These explorations lead to a group of basic protocols which established the area of Secure Multi-Party Computation(SMPC).\\
 Now we will take a short look on the two most famous of these protocols, which both were the basis for a whole family of algorithms established in the years to follow until today.

\subsection{Yaos Garbled Circuit}

Most MPC protocols fall into one of two broad categories: garbled circuits,
and linear-secret-sharing-scheme-based (LSSS-based) MPC. The garbled-circuit
approach, which began with the work of Yao [38], involves some collection of
parties garbling" a circuit to conceal the internal circuit evaluations, and then
later a single party or a collection of parties jointly evaluating the garbled circuit.

 
\subsection{Shamirs Secret Sharing Scheme}

LSSS - linear secret sharing scheme

By contrast, the LSSS-based approach involves using a so-called linear
secret-sharing scheme, in which the parties: share" a secret into several shares
which are distributed to different parties, perform computations on the shares,
and then reconstruct the secret at the end by combining the shares to determine
the output. LSSS-based MPC is traditionally presented in the context of
information-theoretic security, although many modern practical protocols that
realise LSSS-based MPC often make use of computationally-secure primitives
such as somewhat-homomorphic encryption (SHE) [25] or oblivious transfer
(OT) [32]. In this paper, we focus on computationally-secure LSSS-based MPC.


\subsection{Terminology}
Over the years different terminologies came up in the are of SMPC. Following will be a short introduction into some of them, so their definitions are clear.

\subsubsection{Oblivious Transfer}

\subsubsection{Access structures}
There are a lot of different use cases for SMPC, so of course the adversary model changes depending on the system, the security needs, and the amount of parties involved. it is important to differentiate between these different use cases, because the different needs have big implications for security measurements that have to be taken and for runtime complexity. SMPC should run as fast as possible, while still providing all the neccesary security guarantees.

To describe which party has which rights, and how many parties can be corrupted so the security can still be guaranteed, access structures were introduced.
An access str 
d qualified set.  An access structure is called \(Q_l \) if at least l+1 parties are needed to  form a qualified set. 
An (n,t)-threshold scheme with t<n/l means that at least t+1 parties are needed to form a qualified set. Here, n is the number of total parties, and t is number of possible adversaries while not revealing any secrets.
A full threshold scheme means that all parties are needed to form a qualified set. This implies, that, if all other parties except one are corrupted by an adversary, this one party can still rely on the fact that it secret remains secret. Of course this has a huge impact on overhead and performance, but in some cases it can give needed security guarantees. That means a full threshold scheme is a (n, n -1) threshold scheme. (???: IS THIS CORRECT???)


An access structure for a set of parties denes which subsets of parties are
allowed to discover the secret if they pool their information. Such quorums of
parties are often called qualied sets of parties. An access structure is called Q`
(for ` 2 N) if the union of any set of ` unqualied sets of parties is missing at
least one party. We discuss this in some detail later, but for now the reader can
think of an (n; t)-threshold scheme where t < n=` which is where a subset of
parties is qualied if and only if it is of size at least t + 1. Computationallysecure
LSSS-based MPC has recently seen signicant, effcient instantiations
for full-threshold access structures [7, 23, 25, 32], which is where the protocol is
secure if at least one party is honest, even if the adversary causes the corrupt
parties to run arbitrary code (though this behaviour may cause the protocol to
abort rather than provide output to the parties). In the threshold case similar
effcient instantiations are known, such as the older VIFF protocol [21] which
uses (essentially) information-theoretic primitives only.

\subsubsection{Zero Knowledge Proofs (ZKPoKs)}


\subsubsection{Monotone Span Programs}
supposedly unimportant






a.	Part of cryptography that was started in the 1970s and is getting much more relevance in the last years
b.	YAOs Millionaire problem
c.	Mental poker
d.	Yaos garbled circuit
e.	Shamirs secret sharing scheme
i.	Choose random polynomial out of finite field to a prime
ii.	Degree of polynomial t is the number of tolerated adversaries
iii.	Polynomial: f(0) = s
iv.	Send shares to each other player
v.	 T+1 shares needed to reconstruct secret (with Lagrange interpolation in O(n hoch 2))
vi.	These can be used for different operations; for example some calculations can be made on the secrets, and at the end the final result is revealed and calculated and compared; so a result can be calculated without revealing the own secret
f.	Other secret sharing schemes
i.	Replicated (KNF based)
ii.	Dx`NF based
b)	SMPC basics
-	Access structures
-	Montone span programs?
-	Offline/online phase
-	Secret Sharing foundations (mathematical)
c)	Early adoptions of LSSR; MASCOT?
d)	SPDZ
-	Maybe not too many details, because a lot of things are similar to SCALE-MAMBA


Sounds ness slack?


\section{SCALE-MAMBA}\label{sec:scalemamba}

\subsubsection{Overview}

In the last years, the research in SMPC is constantly ongoing, and there are new approaches or improvements to old approaches appearing regulary. But most of these publications only focus on a small area of the whole picture. SCALE-MAMBA is a project that tries to combine the state-of-the-art research into one system. That means, that it is offering kind of an end-to-end system for SMPC.
It is a research system that is continously in development, therefore, there is not a single final version that can be examined. It offers as well a wide range of protocols for different usecases, i.e. it is possible to use the system in different confidurations. That also means for this thesis, that there is not a single process that can be examined. Therefore, this thesis tries to give more an overview how the process works in general, which are the main, especially which are newest and best, parts and where are the problems and bottlenecks.
 
In general, the protocol is split in two parts, first an offline phase and secondly and online phase. In the online phase only the final evaluation of the function is executed. In the offline phase, prior to the online phase, preparations are done by all the parties to prepare for the evaluation. This includes already calculating values for possible multiplications and MACs, so that the online phase can be executed faster. This phase is not completly offline, because the parties still exchange some information which are later needed for the evaluation. But this phasae is not that time critically, that means it can be already executed a lot earlier than the online phase, so that, when the function evaluation is really needed, the result can be calculated in a rather fast time compared to a system that still has to set up everything.

While SCALE-MAMBA also offers different access structures, the most commonly used security configuration is active security with abort in a full threshold scheme, that means that every except one party could be corrupted, and still no information is leaked, because the evaluation is aborted.



Actively Secure
Additive Shares: Innputs are shared via an additive secret sharing scheme.

Scale-mamba: fully integrated offline/online phase
These random triples are further used in the online phase where parties interact by broadcasting data whenever a value is reveale
Privacy and correctness are then guaranteed by authenticated shared values with information-theoretic MACs4 on top of them.
To open a valueJxK, all players Pi broadcast their shares x(i), commit and then open m(i)- x* delta(i). Afterwards they check if the sum of the latter is equal to zero. One can check multiple values at once by taking a random linear 4 These are not be confused with the more common symmetric-key MACs.
7
combination of m(i)-x*delta(i) exactly as in the MAC Check protocol in Figure 5 in Section 3. 


We make all our calculations over a finite field F over a prime p. The field contains p elements, 0 to p-1, and all results are put through modulo p so they are still in F.

Linear addition is easy, because we use a linear secret sharing scheme. Secrets can be added by one party/MACs as well, without any realy computational complexity. 


\subsubsection{Offline phase}

-basic idea
-beaver
-SPDZ
-scale-mamba
-further improvements?
- communication chanels during the offline phase


\subsubsection{Beaver triples}

Beaver triples 




In the offline or pre-processing phase, the most important part is the generation of the beaver triples. These triples  are independent of the computation that is later performed in the online phase. They are used to verify that the computations were done correct, but we will take a closer look into that later./(Or maybe: They are needed for multiplications, because multiple parties have to be involved for them.)

Beaver triples are a tuple of three numbers \((a,b,c)\), with \( a,b,c\in \mathcal{F} )\), with \(a\) and \(b\) being chosen uniformly randomly, and \(a*b=c\).

SPDZ
For the offline phase there is a global public key a global secret key. Every party has a share Delta of this secret key, and there is a distributed decryption protocol, so that the parties decrypt together and every party gets a secret sharing of the cleartext. (Look into more detail in RETSHARE in DPSZ12 by DAMGARD)

For passive security only, the parties can simply broadcast encryptions of randomly sampled shares ai,bi and their share of the MAC key deltai. These encryptions can be added up and multiplied to produce encryptions of (a*b,a* delta,b*delta,a*b*delta) if the encryption allows multiplicative depth two. Distributed decryption then allows the parties to receive an additive secret sharing of each of those values, which already is enough for a triple. Since achieving a higher multiplicative depth is relatively expensive, SPDZ only uses a scheme with multiplicative depth one and extends the distributed decryption to produce a fresh encryption of a·b, which then can be multiplied with the encryption of delta. In the context of an active adversary there are two main issues: First, the ciphertexts input by corrupted parties have to be correct and independent of the honest parties’ ciphertexts. This is where zero-knowledge is applied to prove that certain values lie within a certain bound. Second, the distributed decryption protocol actually allows the adversary to add an error - that is, the parties can end up with a triple (a,b,ab + e) with e known to the adversary and where the MACs have additional errors as well. While an error on a MAC will make the MAC check fail in any case, the problem of an incorrect triple requires more attention. This is where the so-called SPDZ sacrifice comes in. Imagine two triples with potential errors (JaK,JbK,Jab + eK) and (Ja0K,Jb0K,Ja0b0 + e0K), and let t be a random field element. Then, t*(ab + e)-(a0b0 + e0)-(ta-a0)*b-a0*(b-b)0 = tab + te-a0b0-e0-tab-a0b-a0b + a0b0 = te-e0, which is 0 with probability negligible in sec for a field of size at least 2sec if either e 6= 0 or e0 6= 0. The use of MACs means that the adversary cannot forge the result of this computation, hence any error will be caught with overwhelming probability since with the additive secret sharing of our triples the parties have





A. First improvement with MASCOT
using OT for triple generation isntead of SHE

B. Overdrive/TopGear
Improving SHE -> This gave a lot of needed push to SPDZ

In the many iterations of the SPDZ like protocols, there were different ways to guarantee that the parties are not cheating. An important technology for that are the so called Zero Proofs of Konwledge Protocol(ZPoKP).

In the offline phase, ZPoKP are used to guarantee that the Beaver triples are calculated correctly, or atleast that they dont divert too much from the expected result.


ZPoKP are a technique that was introduced  in 1985 by (http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.419.8132\&rep=rep1\&type=pdf). The idea is that one party can prove to another party that it knows a specific value \(x\), without revealing the value of \(x\) to the other person, nor revealing any other knowledge about the value. 
The ZPoKP used in SPDZ is a Schnorr-like protocol (these prtocols ........).

Assumed Alice(in this scenario called the prover) wants to prove to Bob (the verifier) that she knows \( x\) in a Field \( \mathcal{F} \), such that \(f(x)=y\). It is as well assumed, that \( f \) is homomorphic with respect to the field operations in  \( \mathcal{F} \).
\begin{enumerate}
\item Alice chooses a random \( s \in \mathcal{F} \) , calculates \( a = f(s)\) and sends \( a\) to Bob
\item Bob samples a random  \( e \) out of  \( \mathcal{F} \) and sends it to Alice
\item Alice calculates \( z=s+e*x\) and sends it to Bob
\item Bob checks if \( f(z)=a+e*y\)
\end{enumerate}

\textbf{Correctness:}
Bob wants to prove that \( z\) provided by Alice contains the proper \( x\), so that \( f(x)=y\). 
Because f is homomorphic, obviously \( f(z)=f(s)+f(e*x)=f(s)+e*f(x)=a+e*y\) with \(f(s)=a\) and \(f(x)=y\).
So Bob has to calculate \( a+e*y and f(z)\) with the provided \( z\) by Alice. If they are equal, he knows that Alice knows the \( x\) so that \( f(x)=y\).
He can do that, because he got provided the \( a\) and \( z\) by Alice, he knew the \( y\) before the protocol and he chose the \( e\) himself.\\

\textbf{Confidentiality:}
We also have to make sure, that Alice did not share any information regarding her x.
In the firt step she chose a random element s and calulated a=f(s). This information is independent on her secret x, so she didn;t share any information.
When calculating z=s+e*x, she also didnt share any information regarding x, as long it is guaranteed that Bob didnt have any knowledge about the s.
So under the assumption that Alice chooses a new random s each time the protcol is executed, she doesn't share any information regarding her secret x.\\



The semi-homomorphic solution works roughly as follows: One party sends an encryption Enc(a) of their input under their own public key to the other, which replies by C := b*Enc(a)-Enc(cB), where b denotes the second party’s input, and cB is chosen at random. Any semi-homomorphic encryption scheme allows the multiplication of a known value with a ciphertext, hence the decryption of the second message is cA := b*a-cB, which makes (cA,cB) an additive secret sharing of a*b. Here the noise of C might reveal information about b but this can be mitigated by adding random noise from an interval that is sec larger than the maximum noise of C. This technique, sometimes called “drowning”, is also used in the distributed decryption of SPDZ. 



In one of there earlier works, BDOZ, pairwise MACs were used to authentificate the secret sharing between the parties. It used a pairwise multiplication protocol with linear homomorpic encryption. To guarantee the data integritym pairwise zero-knowledge proofs were used, in total O(n2) of them. 
In SPDZ instead of HE, SHE based on the BGV ecnryption scheme was used, reducing the amount of ZK proofs per triple by a factor of n and as well the overhead per triple, because they used a single ZKPoK for proving thousand of triples.
Because BGV is a lattice based SHE scheme and therefore the ZKPoK are relatively expensive, for a long while a straetgy called cut-and-choose was used, which only offered covert security. 
In 2016 the part was changed to an OT based offline phase called MASCOT, which sped up tbe process by two order of magnitude compared to the previous implementation(Damgard et al. (ESORICS ’13). ).
But shortly afterwards it was turned back to a SHE based offline phase, with the introduction of the so called Overdrive, being at least 6 times faster than MASCOT. Overdrive includes two parts, a protocol called Low Gear protocol for small numbers, and a proctocol called High Gear for larger numbers. In version 1.2 of Scale-mamba only the HighGear protocol was used, and in version 1.3 solely an improvement to this protocol is supported, called TopGear.




The High Gear protocol tweaked the original ZKPoK used in SPDZ. The basic idea is, that all the parties prove a single joint statement instead of multiple smaller ones.

SoundsnessSlack? protocols based on this, because the protocols which prove the exact bounds are too slow in praxis

But it still isn't as efficient and secure as it could be, because the Sounds ness security SndSec is related to the 

The zero-knowledge security ZK sec is related to a statistical distance, whereas the soundness security Snd sec is related to the probability that an adversary can cheat in an interactive protocol. A low value for Snd sec is rather acceptable than a low value for ZK sec. 2. The practical complexity of the protocol, in particular the memory and computational consumption, is dominated by Snd sec. It turns out that ZK sec has very virtually no effect on the overall execution time of the offline phase, for large values of p.

Therefore, in the current iteration of Scale-Mamba an improved version of the HighGear protocol is implemented.



First: compute SPDZ style MACs; additive secret sharing of the product of a value, and of a global MAC key, which is secret shared additevly as well (With ZPoKP)
In the authentication protocol, we make use of the fact that changing values are always multiplied with the same share of the MAC key

Multiplication triple generation: 2 party protocol; --> Reduction of communication channels(link paper); reduction of most part to Q2; this enables us to not have a complete network of communication channels for most of the protocol (offline phase)

Section3.3 Overdrive: Triple Generation
 In the triple generation, however, both values change from triple to triple, thus we rely on the SPDZ sacrifice there. For this, we use a trick used by Keller et al. that reduces the complexity by generating a pair of triples ((a,b,ab),(a0,b,a0b)) for the sacrifice instead of two independent triples. 

Before calculated with HE, then in MASCOT with OT, now with SHE


ZK proofs: mitigiate too much noise generatiuon by adversaries


Mac key: generation of mac key, generation of multiplication triples (SPDZ: HE, SCALE-MAMBA:SHE)
Sacrifice of triples to check correctness


\subsubsection{Online Phase}



We  will  use  unconditionally  secure  MACs  to  protect  secret  values  from  beingmanipulated by an active adversary. 
global key Achosenrandomly inFpk, and for each secret valuea, we will shareaadditively among the players, and wealso secret-share a MAC Aa


\subsubsection{Preliminaries}


Now we assume that the offline phase was succesfully executed, so all preliminaries are given to execute the online phase. It's main goal is to evaluate a specified circuit with secret inputs by the different parties. So this is the heart of the system, the part where the real computatiuon is executed. 
It is important to note, that the online phase is nearly perfectly optimized when assuming the offline phase was carried out succesfully. The online phase has a runtime complexity in O(n), and therefore there is not a really big performance impact. It is also noteworthy, that in the online phase only only computational and no information theoretical problems are solved. All this leads to the fact, that there is not really any change in the online phase in the SPDZ like protocols in the last years, therefore the online phase is the same like in the earlier version of SPDZ ~\cite{cryptoeprint:2011:535}.\\


We assume following preliminaries are given after the execution of the offline phase:\\
\begin{enumerate}
\item There are \(n\) parties \(P_1,...,P_n\)
\item There is a given function \(f(a_1,...,a_m)\) which the parties want to evaluate together. The inputs are secret, and each input is hold by exactly one party.
\item There is a global MAC key \( \alpha\) that is secret to every party and additively shared, so that every party \( P_i\) has a share  \( \alpha_i\) so that  \( \alpha=\alpha_1+...+\alpha_n\)

\end{enumerate}

Following, it is going to be demonstrated, how addition and multiplication are done in this environment. This is sufficient, because a group(XXX???) with addition and multiplication is already touring complete, so there is no need for any other operation. (ADD LINK HERE)\\


Sharing of values:\\
After sharing a value \( a \in F_p\), it is represented as following tuple:\\
$\langle a\rangle=(\delta_a, (a_1,...,a_n),(\gamma (a)_1,...,\gamma (a)_n))$
\\With:
\begin{itemize}
\item $ a=(a_1+...+a_n)$
\item $ \gamma (a)=((\gamma (a)_1+...+\gamma (a)_n))=\alpha(a+\delta)$
\item Every party \( P_i\) holds a share of \( a\) as tuple \(\langle a_i\rangle = (\delta_a,a_i,\gamma(a)_i )\)

\end{itemize}




\subsubsection{Addition}
Assumed there are two values \( a\) and \( b\) which should be added together and both are secret inputs from two different parties. Naturally, both of these values are additively shared between all the parties, i.e. every party has a share \( \langle a_i\rangle\) and a share \( \langle b_i\rangle\).\\

Then every party \( P_i\) adds up their local shares, so that:\\
$$\langle c_i\rangle=\langle a_i\rangle+\langle b_i\rangle=((\delta_a+\delta_b),(a_i+b_i),\gamma (a)_i+\gamma (b)_i))$$
Correctness: Afterwards, \( c=a+b\) is obviously additively shared between the parties and can be used for further computations.\\

(Maybe go more in detail about correctness)


\subsubsection{Addition with constant}
Adding a public constant is really simple in this representation. Because \( \gamma (a)=\alpha(a+\delta)\), adding a constant \(c\) to a additively shared value \(a\) is done by:\\
$$\langle a\rangle+c=(\delta-c,(a_1+c,a_2,...,a_n),,(\gamma (a)_1,...,\gamma (a)_n)$$
Correctness: It can be seen, that the constant is only added to one shared value and subtracted from \( \delta\). Because of that, \( \alpha(a+\delta)\) stays the same, so the same shared MAC values like before can be used. So \(a+c\) is also properly additively shared.\\

\subsubsection{Multiplication with constant}
Multiplicating with a public constant is as well really simple and can also be done by each party invdividually. It is defined as:\\
$$c*\langle a\rangle=\langle c*a\rangle=(c*\delta,(c*a_1,...,c*a_n),,(c*\gamma (a)_1,...,c*\gamma (a)_n)$$
Correctness:(TO BE DONE\\

\subsubsection{Multiplication}

Multiplication is the only operation,except for distributing the shares and calculating and verifying the end result, where the parties have to interact in the online phase.
Assumed there are two values \( a\) and \( b\) which should be multipled with each other. Naturally, each party has the shares \(\langle a_i\rangle \) and \(\langle b_i\rangle \).\\
For each multiplication operation, we need one of the Beaver triples \( (\langle x_1 \rangle ,\langle y_1\rangle , \langle z_1\rangle )\) generated in the offline phase. In the offline phase we checked the quality of our triples, but we still allowed the possibility that each triple has an error \(e\) so that \(c=a*b+e\). To check the quality of our triple, we use a second triple \( (\langle x_2 \rangle ,\langle y_2\rangle ,\langle z_2\rangle )\) in a procedure called sacrificing it. Both triples are additively shared between all parties like the input values. In SPDZ both triples are completly unrelated to each other, and the sacrificing is done as follows:\\


\begin{enumerate}
\item Choose a random variable \( r\) and open it to the other parties. This is done by each party generating a random share \(r_i\) and then calculating \(r=r_1+...+r_n)\).
\item The parties calculate  \( p=t*\langle x_1 \rangle - \langle x_2 \rangle \) and \( \sigma=\langle y_1 \rangle -  \langle y_2 \rangle \) and partially open the results afterwards
\item The parties calculate \(\phi = t * \langle z_1 \rangle\ - \langle z_2 \rangle - \sigma * \langle x_2 \rangle - p * \langle y_2 \rangle - \sigma * p)\) and then partially open the result
\item If \( \phi \) is 0 then the triples are ok and it is proceeded with \( (\langle x_1 \rangle ,\langle y_1\rangle , \langle z_1\rangle )\). Otherwise the system detected a malicious adversary and it aborts.\\
\end{enumerate}


Partially opening  of values: All players send their respective shares of a value, but not the MAC value, to one chosen party \(P_i\) which summs up all values and then broadcasts the result. In praxis this party is changing for every opening to balance the workload.\\
Fully opening of values: In this case all players broadcast their respective shares and the respective MACs to all players, so all players can verify the result.\\

Correctness: If we simplify \( \phi \), we can see that every term disappears (given that the triples are proper triples):
$$\phi = t*z_1 - z_2 - y_1 + y_1*x_2 + y_2 * x_2 - t * x_1 * y_2 + x_2*y_2 - t*x_1*y_1 + t*x_1*y_2 + x_2*y_1 - x_2*y_2$$
$$ = t*(z_1 - x_1*y_2+x_1*y_2 -x_1*y_1) + y_1*x_2 - x_2*y_1+ x_2*y_2 - z_2 + x_2*y_2 -  x_2*y_2$$
$$= t* (z_1 - x_1*y_1) + x_2*y_2 - z_2 $$
So we can see that \( \phi = 0 \Leftrightarrow x_1 * y_1 = z_1 \land x_2*y_2=z_2 \), so we know the triple is correct. \\
In this process we didn't reveal the triple \( (\langle x_1 \rangle ,\langle y_1\rangle , \langle z_1\rangle ) \), so now we can use it for the multiplication knowing that one the one hand it is still secretly shared and unknown and on the other hand that it was not modified by an adversary.\\




There is a small improvement in SCALE-MAMBA compared to SPDZ regarding the triple generation that was added later in ~\cite{PAPER WITH TRIPLE}. The idea is to not sacrifice a random second triple, but a similiar triple ....


Now in the next step the multiplication of \(\langle a \rangle \) and \(\langle b \rangle \) is executed with the help of the triple.
\begin{enumerate}
\item The parties calculate \( \epsilon = \langle a \rangle - \langle x_1 \rangle \) and partially open it
\item The parties calculate \( \delta = \langle b \rangle - \langle y_1 \rangle \) and partially open it
\item The parties calculate \( \langle c \rangle \langle z_1 \rangle + \epsilon * \langle b \rangle + \delta * \langle a \rangle + \epsilon * \delta \) 
\end{enumerate}
Correctness: 
$$  \langle a \rangle * \langle b \rangle = \langle (a-x_1+x_1) \rangle * \langle (b-y_1+y_1) \rangle$$
$$ = ( \epsilon  +\langle  x_1 \rangle ) * ( \delta  + \langle y_1 \rangle )$$
$$ = \langle x_1 \rangle * \langle y_1 \rangle + \epsilon * \langle b \rangle + \delta * \langle a \rangle + \epsilon * \delta =  \langle c \rangle $$

So, as we can see, the calculations are correct and at the same time no information of \(\langle a \rangle \) or \(\langle b \rangle \) was revealed.\\


\subsubsection{Verifying Correctness}
At the end of the computation, we have to find out the total calculated result. After all computations were executed, every party has a share of the final result \( r_i\), a share of the MAC value \( \gamma(r)_i)\) of the final result and a share of the global MAC key \( \alpha_i \). The verification is done as follows:

\begin{enumerate}
\item Every party  opens their share \ (r_i\) and their share of the MAC value \( \gamma(r)_i) \)
\item Every party computes \( r = \sum{i=1}^n r_i \) 
\item Every party computes  \( \gamma(r)_i = \sum{i=1}^n \gamma(r)_i \)
\item Every party computes  \( \sigma_i =  \gamma(r)_i - \alpha_i * r\) and shares it to all the other parties
\item Every party computes \(\sum{i=1}^n \sigma_i \) and checks if it is \(0\). If it is  \(0\), the computation was correct.
\end{enumerate}
Correctness: 
$$ \sum{i=1}^n \sigma_i = n * \gamma(r) - n * \sum{i=1}^n r  \sum{i=1}_n \alpha_i  $$

 Now, every party  opens their share \(r_i\) and of the MAC value  and every party computes \(r = \sum{i=1}^n r_i \) for themselves.\\

To verify the correctness of this result every party also computes \( \gamma(r) = \sum{i=1}^n \gamma(r)_i \)


Now that we have the final result, we also have to check the 

MAC is only opened at the end, so it can be found out before by an adversary. Therefore in this phase we can, if the value is correct, expect that the mac was not modified by an adversary and therefore the complete computation was not modified.



In the online phase the main task is to evaluate an arbitrary circuit with secret inputs. After the parties have provided their inputs using the Input command, the next step is to perform addition and multiplication between authenticated shared values. Since the addition is linear, it can be done via local computation. However multiplying two valuesJxK,JyKrequires some interaction between the parties. To computeJx*yKa fresh random tripleJaK,JbK,JcK=JabKhas to be available for Beaver’s trick [Bea92]. It works by opening XXXXFORMULAXXX  respectively. Then the authenticated product can be obtained by setting XXXXFORMULAXXX


So we assume that every party \(i\) holds an input \(a_i\)


Additive shared: every party has part ai of a
MAC: mac key is shared as well


Addition: Easy, just add up shares
Multiplication by scalar: easy
Addition by scalar: easy
Multiplication: 



We assume following preliminaries for our online phase:
\begin{enumerate}
\item We have \(n\) parties \(P_1,...,P_n\) 

\end{enumerate}




\subsubsection{Sacrificing}
a,b, c=ab
1.e = Open([x+a]
)2.d = Open([y+b])
3.[xy] = [c]+e[y] + d[x] -ed




a)	Why we need it? Problems of SPDZ, other SMPC protocols
b)	Architecure
-	Written in C++
-	Scale: Secure Computation Algorithms from LEuven
o	SMPC foundations
0 00 o	Code base based on different projects like SPDZ, HE…?,.
o	Combination of offline  online phase
o	We will focus more on this then on the Compiler part, its more relevant for this thesis
o	
-	Mamba: Multiparty AlgorithMs Basic Argot
o	Compiler; similar to python
o	Why necessary? Easily able to write own configurations for SMCP for SCALE-MAMBA
c)	Idea, Computational Logic

Scale-Mamba is an implementation of SPDZ among other protocols. SPDZ is right now the most efficient protocol in use. 

Most LSSS-based MPC protocols split the computation into two parts: an of-

ine phase, in which parties interact using expensive" public-key cryptography
to lay the groundwork for an online phase in which only cheap" informationtheoretic
primitives are required. The online phase is where the actual circuit
evaluation takes place. For the access structures considered in this work, namely
Q2 structures, the offline phase is almost as fast as the online phase. Thus the
goal here is to minimize the cost of communication in both phases.

-	Online  Offline phase
-	Offline phase:
o	Calculation of beaver triples
o	Precalculations like MAC?
o 	Offline phase based on Overdrive protocols (before Mascot)
		Low-Gear: For smal numbers, O(n to the power of 2), faster than O(n )
		High-gear: For high numbers (for SCALE-MAMBA: Only high gear is implemented)

-	Online phase:
o	Secret sharing

SPDZ  Secret  Sharing.This  SPDZ  protocol  [15]  processes  data  using  an  authenticated  secret  sharingscheme defined over a finite fieldFp, wherepis prime. The secret sharing scheme is defined as follows: EachpartyPiholds a share XXXX a global MAC key XXXX. A data element XXXX held in secretshared form as a tuple  xy el[n], such that XXX. We denote a valuexheld in such asecret shared form as x. The main goal of the SPDZ offline phase is to produce random triples (abc)such thatc=a*b. If we wish to denote the specific value on which yiis a MAC share then we write yi[x].

o	Sacrifice of triples to check calculation results
o	Check for adversaries (MAC?)
o	Abortion
-	Options/ Configurations:
o	It is possible to use different setups, depending on the taste of the user
d)	Performance, real world usage, problems, upcoming developments, 
-	Upcoming: Calculating offline data before, and then compiling the Mamba code just in time (especially full threshold access structures need a lot of time)




\section{Comparison}\label{sec:comparison}


a.	What else is out there?
b.	Different use cases – when which SMPC tool is more useful; what are the strengths of SCALE-MAMBA compared to other ones?
c.	Factual comparisons

SCAPI
SCAPI is an open-source Java library for implementing secure two-party and multiparty computation protocols (SCAPI stands for the “Secure Computation API”). It provides a reliable, efficient, and highly flexible cryptographic infrastructure.

https://scapi.readthedocs.io/en/latest/intro.html


\section{Outlook and Conclusion}\label{sec:outlook}

a.	What brings the future in general in SMPC?
b.	SMPC is a technology that will shape the future (at least a bit)


a.	SCALE-MAMBA is amazing
b.	We saw how it works in which cases it is more useful
c.	We saw why SMPC is necessary; we saw that we need it (or at least we should use it)


Basically most research going on in the offline phase : online phase is really straight forward right now, O(n), only simple calculations, really fast


\section{TODO LIST}\label{sec:xxx}


Format: 
Your report should have a minimum length of 15 pages LNCS Style, excluding references. 
Your report has to include references, but they do not count towards your total page limit. The 'literature list' is the list of references. 

Try not to write more than 20 pages unless you feel you have a very good reason. 

Template: 
The LNCS is template is available for Latex [1] and Word [2] on the Springer page, 
but I suggest you use this quick start version [3]. 

How to correctly include references in your literature list: 

Please refer to e.g. the Chicago manual of style [5].

Any valid reference style is accepted, as there are many styles, and as they basically contain the same information. 



Next steps: 
I will send you instructions about the peer review process closer to the next deadline.



Best regards, Benjamin Heitmann.



-	Use Latex
-	Find examples/ empirical results
-	Gmw protocol – scapi library LSSR based, passive as comparison
-	Reusing results: maybe check in night for adversaries?
-	Could be nice to include reuse
-	



\section{Bibliography}\label{sec:biblio}


\section{Abbreviations}\label{sec:abb}


List of abbrviations
LSSR
SMPC
SPDZ
OT
MAC
HE
SHE
SCALE
MAMBA




\section{Introduction}\label{sec:intro}

The remainder of the paper starts with a presentation of related work (\cref{sec:relatedwork}).
It is followed by a presentation of hints on \LaTeX{} (\cref{sec:hints}).
Finally, a conclusion is drawn and outlook on future work is made (\cref{sec:outlook}).

\section{Related Work}
\label{sec:relatedwork}

is a graphical \commentontext{modeling}{modeling with one \qq{l}, because of AE} tool.


\section{LaTeX Hints}
\label{sec:hints}

\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth]{example-image-golden}
  \caption{Simple Figure. }
  \label{fig:simple}
\end{figure}

\begin{table}
  \caption{Simple Table}
  \label{tab:simple}
  \centering
  \begin{tabular}{ll}
    \toprule
    Heading1 & Heading2 \\
    \midrule
    One      & Two      \\
    Thee     & Four     \\
    \bottomrule
  \end{tabular}
\end{table}

\begin{lstlisting}[
  % one can adjust spacing here if required
  % aboveskip=2.5\baselineskip,
  % belowskip=-.8\baselineskip,
  caption={Example Java Listing},
  label=L1,
  language=Java,
  float]
public class Hello {
    public static void main (String[] args) {
        System.out.println("Hello World!");
    }
}
\end{lstlisting}

\begin{lstlisting}[
  % one can adjust spacing here if required
  % aboveskip=2.5\baselineskip,
  % belowskip=-.8\baselineskip,
  caption={Example XML Listing},
  label=L2,
  language=XML,
  float]
<example attr="demo">
  text content
</example>
\end{lstlisting}

\Cref{L1,L2} show listings typeset using the \texttt{lstlisting} environment.

cref Demonstration: Cref at beginning of sentence, cref in all other cases.

\Cref{fig:simple} shows a simple fact, although \cref{fig:simple} could also show something else.

\Cref{tab:simple} shows a simple fact, although \cref{tab:simple} could also show something else.

\Cref{sec:intro} shows a simple fact, although \cref{sec:intro} could also show something else.

Brackets work as designed:
<test>
One can also input backquotes in verbatim text: \verb|`test`|.

The symbol for powerset is now correct: $\powerset$ and not a Weierstrass p ($\wp$).

\begin{inparaenum}
  \item All these items...
  \item ...appear in one line
  \item This is enabled by the paralist package.
\end{inparaenum}

Please use the \qq{qq command} or the \enquote{enquote command} to quote something.
``something in quotes'' using plain tex syntax also works.

You can now write words containing hyphens which are hyphenated (application"=specific) at other places.
This is enabled by an additional configuration of the babel package.
In case you write \qq{application-specific}, then the word will only be hyphenated at the dash.
You can also write applica\allowbreak{}tion-specific, but this is much more effort.

The words \qq{workflow} and \qq{dwarflike} can be copied from the PDF and pasted to a text file.

Numbers can written plain text (such as 100), by using the siunitx package like that:
\SI{100}{\km\per\hour},
or by using plain \LaTeX{} (and math mode):
$100 \frac{\mathit{km}}{h}$.

\section{Conclusion and Outlook}
\label{sec:outlook}
\lipsum[1-2]

\subsubsection*{Acknowledgments}
\ldots

In the bibliography, use \texttt{\textbackslash textsuperscript} for \qq{st}, \qq{nd}, \ldots:
E.g., \qq{The 2\textsuperscript{nd} conference on examples}.
When you use \href{https://www.jabref.org}{JabRef}, you can use the clean up command to achieve that.
See \url{https://help.jabref.org/en/CleanupEntries} for an overview of the cleanup functionality.


\renewcommand{\bibsection}{\section*{References}} % requried for natbib to have "References" printed and as section*, not chapter*
% Use natbib compatbile splncsnat style.
% It does provide all features of splncs03, but is developed in a clean way.
% Source: http://phaseportrait.blogspot.de/2011/02/natbib-compatible-bibtex-style-bst-file.html
\bibliographystyle{splncsnat}
\begingroup
  \ifluatex
    %try to activate if bibliography looks ugly
    %\sloppy
  \else
    \microtypecontext{expansion=sloppy}
  \fi
  \small % ensure correct font size for the bibliography
  \bibliography{paper}
\endgroup

% Enfore empty line after bibliography
\ \\
%
All links were last followed on October 5, 2017.
\end{document}
 